// src/utils/calcEngine.js

/**
 * Calc Engine (Safe Expression Evaluator)
 * Input: validated numeric expression string like: "1 + 2 * (3 ^ 2)"
 * Output: number (JS Number)
 *
 * Supports: + - * / % ^ ( )
 * - Exponent (^) is right-associative
 * - Handles unary + / - (e.g., "-3", "2*-4", "-(2+1)")
 *
 * Throws errors with stable codes to test easily.
 */

class CalcError extends Error {
  constructor(code, message) {
    super(message);
    this.name = "CalcError";
    this.code = code;
  }
}

const ERR = {
  EMPTY_EXPRESSION: "EMPTY_EXPRESSION",
  MALFORMED_EXPRESSION: "MALFORMED_EXPRESSION",
  INVALID_TOKEN: "INVALID_TOKEN",
  INVALID_OPERATOR_SEQUENCE: "INVALID_OPERATOR_SEQUENCE",
  UNMATCHED_PARENTHESIS: "UNMATCHED_PARENTHESIS",
  DIVISION_BY_ZERO: "DIVISION_BY_ZERO",
};

const OPERATORS = {
  "+": { prec: 1, assoc: "L", arity: 2 },
  "-": { prec: 1, assoc: "L", arity: 2 },
  "*": { prec: 2, assoc: "L", arity: 2 },
  "/": { prec: 2, assoc: "L", arity: 2 },
  "%": { prec: 2, assoc: "L", arity: 2 },
  "^": { prec: 3, assoc: "R", arity: 2 },

  // Internal unary operators (generated by tokenizer)
  "u+": { prec: 4, assoc: "R", arity: 1 },
  "u-": { prec: 4, assoc: "R", arity: 1 },
};

function isOperator(tok) {
  return Object.prototype.hasOwnProperty.call(OPERATORS, tok);
}

function isNumberToken(tok) {
  return typeof tok === "number" && Number.isFinite(tok);
}

/**
 * Tokenizer:
 * - Parses integers and decimals: 12, 3.14 (optional support)
 * - Recognizes operators and parentheses
 * - Converts unary + / - into "u+" / "u-"
 *
 * Assumes validator already ensured only allowed characters exist.
 */
function tokenize(expr) {
  const s = expr.replace(/\s+/g, "");
  if (!s) throw new CalcError(ERR.EMPTY_EXPRESSION, "Expression is empty.");

  const tokens = [];
  let i = 0;

  // Tracks what kind of token we expect to help detect unary operators
  // true => at start or after '(' or after an operator => a number or '(' or unary is allowed
  let expectingValue = true;

  while (i < s.length) {
    const ch = s[i];

    // Number (supports decimals)
    if (/\d/.test(ch) || ch === ".") {
      if (!expectingValue) {
        // e.g., "2 3" (without operator) would end up here after stripping spaces
        throw new CalcError(
          ERR.INVALID_OPERATOR_SEQUENCE,
          "Missing operator between values."
        );
      }

      let start = i;
      let dotCount = 0;

      while (i < s.length && (/[\d.]/.test(s[i]))) {
        if (s[i] === ".") dotCount++;
        if (dotCount > 1) {
          throw new CalcError(ERR.INVALID_TOKEN, "Invalid number format.");
        }
        i++;
      }

      const raw = s.slice(start, i);
      const num = Number(raw);

      if (!Number.isFinite(num)) {
        throw new CalcError(ERR.INVALID_TOKEN, `Invalid number: ${raw}`);
      }

      tokens.push(num);
      expectingValue = false;
      continue;
    }

    // Parentheses
    if (ch === "(") {
      if (!expectingValue) {
        // e.g., "2(3+4)" not supported unless you want implicit multiplication.
        throw new CalcError(
          ERR.INVALID_OPERATOR_SEQUENCE,
          "Missing operator before '('."
        );
      }
      tokens.push(ch);
      expectingValue = true;
      i++;
      continue;
    }

    if (ch === ")") {
      if (expectingValue) {
        // e.g., "( )" or "(+)" or "(*2)"
        throw new CalcError(
          ERR.MALFORMED_EXPRESSION,
          "Empty or malformed parentheses."
        );
      }
      tokens.push(ch);
      expectingValue = false;
      i++;
      continue;
    }

    // Operators
    if ("+-*/%^".includes(ch)) {
      if (expectingValue) {
        // unary +/-
        if (ch === "+" || ch === "-") {
          tokens.push(ch === "+" ? "u+" : "u-");
          i++;
          expectingValue = true;
          continue;
        }
        // can't start with * / % ^ or have them after '(' / another operator
        throw new CalcError(
          ERR.INVALID_OPERATOR_SEQUENCE,
          `Operator '${ch}' cannot appear here.`
        );
      } else {
        // binary operator
        tokens.push(ch);
        i++;
        expectingValue = true;
        continue;
      }
    }

    throw new CalcError(ERR.INVALID_TOKEN, `Unexpected character: ${ch}`);
  }

  // Expression can't end expecting a value, e.g., "1+"
  if (expectingValue) {
    throw new CalcError(
      ERR.MALFORMED_EXPRESSION,
      "Expression ends with an operator or is malformed."
    );
  }

  return tokens;
}

/**
 * Shunting-yard: infix tokens -> RPN tokens
 */
function toRpn(tokens) {
  const output = [];
  const ops = [];

  for (const tok of tokens) {
    if (isNumberToken(tok)) {
      output.push(tok);
      continue;
    }

    if (tok === "(") {
      ops.push(tok);
      continue;
    }

    if (tok === ")") {
      let foundLeftParen = false;
      while (ops.length) {
        const top = ops.pop();
        if (top === "(") {
          foundLeftParen = true;
          break;
        }
        output.push(top);
      }
      if (!foundLeftParen) {
        throw new CalcError(
          ERR.UNMATCHED_PARENTHESIS,
          "Unmatched ')' found."
        );
      }
      continue;
    }

    if (isOperator(tok)) {
      const o1 = tok;
      const { prec: p1, assoc: a1 } = OPERATORS[o1];

      while (ops.length) {
        const o2 = ops[ops.length - 1];
        if (!isOperator(o2)) break;

        const { prec: p2 } = OPERATORS[o2];

        const shouldPop =
          (a1 === "L" && p1 <= p2) ||
          (a1 === "R" && p1 < p2);

        if (!shouldPop) break;

        output.push(ops.pop());
      }

      ops.push(o1);
      continue;
    }

    throw new CalcError(ERR.INVALID_TOKEN, `Invalid token: ${String(tok)}`);
  }

  while (ops.length) {
    const top = ops.pop();
    if (top === "(" || top === ")") {
      throw new CalcError(
        ERR.UNMATCHED_PARENTHESIS,
        "Unmatched '(' found."
      );
    }
    output.push(top);
  }

  return output;
}

/**
 * Evaluate RPN tokens using a stack
 */
function evalRpn(rpn) {
  const stack = [];

  for (const tok of rpn) {
    if (isNumberToken(tok)) {
      stack.push(tok);
      continue;
    }

    if (!isOperator(tok)) {
      throw new CalcError(ERR.INVALID_TOKEN, `Invalid RPN token: ${tok}`);
    }

    const opInfo = OPERATORS[tok];

    if (opInfo.arity === 1) {
      if (stack.length < 1) {
        throw new CalcError(ERR.MALFORMED_EXPRESSION, "Malformed expression.");
      }
      const a = stack.pop();
      if (tok === "u+") stack.push(+a);
      else if (tok === "u-") stack.push(-a);
      else throw new CalcError(ERR.INVALID_TOKEN, `Unknown unary op: ${tok}`);
      continue;
    }

    // binary
    if (stack.length < 2) {
      throw new CalcError(ERR.MALFORMED_EXPRESSION, "Malformed expression.");
    }
    const b = stack.pop();
    const a = stack.pop();

    let res;
    switch (tok) {
      case "+": res = a + b; break;
      case "-": res = a - b; break;
      case "*": res = a * b; break;
      case "/":
        if (b === 0) throw new CalcError(ERR.DIVISION_BY_ZERO, "Division by zero.");
        res = a / b;
        break;
      case "%":
        if (b === 0) throw new CalcError(ERR.DIVISION_BY_ZERO, "Modulus by zero.");
        res = a % b;
        break;
      case "^":
        res = Math.pow(a, b);
        break;
      default:
        throw new CalcError(ERR.INVALID_TOKEN, `Unknown operator: ${tok}`);
    }

    if (!Number.isFinite(res)) {
      throw new CalcError(ERR.MALFORMED_EXPRESSION, "Result is not a finite number.");
    }

    stack.push(res);
  }

  if (stack.length !== 1) {
    throw new CalcError(ERR.MALFORMED_EXPRESSION, "Malformed expression.");
  }

  return stack[0];
}

/**
 * Public API:
 * evaluateNumericExpression("1 + 2*(3^2)") -> 19
 */
function evaluateNumericExpression(validNumericExpression) {
  const tokens = tokenize(validNumericExpression);
  const rpn = toRpn(tokens);
  return evalRpn(rpn);
}

module.exports = {
  evaluateNumericExpression,
  tokenize,
  toRpn,
  evalRpn,
  CalcError,
  ERR,
};
